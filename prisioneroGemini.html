<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dilema del Prisionero - Simulaci√≥n Avanzada</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            max-width: 1200px;
            width: 100%;
        }

        .card {
            background-color: #ffffff;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: all 0.3s;
        }

        .header {
            grid-column: 1 / -1;
            text-align: center;
            padding: 16px;
            background-color: #1f2937;
            color: white;
            border-radius: 12px;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
        }

        /* Controles y Tablero */
        .controls-panel {
            grid-column: 1 / 2;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .board-panel {
            grid-column: 2 / 3;
            overflow: hidden; 
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .player-card {
            background-color: #f3f4f6;
            border: 1px solid #e5e7eb;
            padding: 16px;
        }
        
        /* Instrucciones de teclado */
        .key-hint {
            font-size: 0.75rem;
            opacity: 0.7;
            display: block;
            margin-top: 4px;
        }

        .btn-move {
            transition: all 0.1s ease-in-out;
            padding: 10px 20px;
            font-weight: 600;
        }

        .btn-cooperate {
            background-color: #10b981; /* Emerald 500 */
            color: white;
            border: none;
        }

        .btn-traitor {
            background-color: #ef4444; /* Red 500 */
            color: white;
            border: none;
        }

        .btn-cooperate:hover:not(:disabled) { background-color: #059669; }
        .btn-traitor:hover:not(:disabled) { background-color: #dc2626; }

        .selected-cooperate {
            border: 3px solid #047857 !important;
            box-shadow: 0 0 10px #34d399;
        }
        .selected-traitor {
            border: 3px solid #b91c1c !important;
            box-shadow: 0 0 10px #f87171;
        }

        /* Contenedor sincronizado para el scroll */
        #synchronized-history {
            overflow-x: auto; /* CR√çTICO: El contenedor padre maneja el scroll */
            overflow-y: hidden;
            border-radius: 6px;
            padding: 4px;
            background-color: #e5e7eb;
            max-height: 70px; 
        }
        
        /* Filas de Historial: Altura ajustada */
        .visual-history-row {
            display: flex;
            margin-bottom: 4px; 
            height: 28px; 
            white-space: nowrap; 
            padding-right: 20px; 
        }
        .visual-history-row:last-child {
             margin-bottom: 0;
        }

        /* Bolitas de Movimiento: Tama√±o reducido */
        .move-circle {
            width: 20px;
            height: 20px;
            min-width: 20px;
            border-radius: 50%;
            margin-right: 2px; 
            display: inline-block;
            transition: background-color 0.3s;
        }
        .C { background-color: #10b981; } /* Cooperar - Verde */
        .T { background-color: #ef4444; } /* Traicionar - Rojo */

        /* Historial de Partidas */
        #summary-list {
            list-style: none;
            padding: 0;
            max-height: 300px;
            overflow-y: auto;
            border-top: 1px solid #e5e7eb;
            padding-top: 10px;
        }
        .match-summary-item {
            padding: 8px 0;
            border-bottom: 1px dashed #d1d5db;
            font-size: 0.9em;
            color: #4b5563;
        }
        .match-summary-item:last-child {
            border-bottom: none;
        }

        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
            }
            .controls-panel, .board-panel {
                grid-column: 1 / -1;
            }
            .btn-move {
                padding: 12px;
                font-size: 0.9em;
            }
        }
    </style>
</head>
<body class="bg-gray-100">
    <div class="container mt-5">
        <div class="header">
            <h1 class="text-3xl font-bold">Simulador del Dilema del Prisionero</h1>
            <p class="mt-2 text-gray-300">Explora la cooperaci√≥n y la traici√≥n en un juego de suma no cero.</p>
        </div>

        <!-- Panel de Controles -->
        <div class="controls-panel card">
            <h2 class="text-xl font-semibold mb-4 text-gray-800">‚öôÔ∏è Configuraci√≥n del Juego</h2>
            
            <!-- Selector de Estrategias -->
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label for="strategy-1" class="block text-sm font-medium text-gray-700">Jugador 1</label>
                    <select id="strategy-1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 bg-gray-50 border">
                        <option value="Human" selected>Humano</option> <!-- DEFAULT: Humano -->
                        <option value="Always Cooperate">Siempre Coopera</option>
                        <option value="Always Traitor">Siempre Traiciona</option>
                        <option value="Tit-for-Tat">Tit-for-Tat (Ojo por Ojo)</option>
                        <option value="Tit-for-Two-Tats">Tit-for-Two-Tats (Perdona 1)</option>
                        <option value="Grim Trigger">Gatillo Siniestro (Venganza Eterna)</option>
                        <option value="Pavlov">Pavlov (Gana-Qu√©date, Pierde-Cambia)</option>
                        <option value="Majority">Mayor√≠a de Votos (Sigue a la Multitud)</option>
                        <option value="Random_50">Aleatoria (50/50)</option>
                        <option value="Random_70">Aleatoria (70% C)</option>
                        <option value="Random_30">Aleatoria (30% C)</option>
                    </select>
                </div>
                <div>
                    <label for="strategy-2" class="block text-sm font-medium text-gray-700">Jugador 2</label>
                    <select id="strategy-2" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 bg-gray-50 border">
                        <option value="Human">Humano</option>
                        <option value="Always Cooperate">Siempre Coopera</option>
                        <option value="Always Traitor">Siempre Traiciona</option>
                        <option value="Tit-for-Tat" selected>Tit-for-Tat (Ojo por Ojo)</option> <!-- DEFAULT: TFT -->
                        <option value="Tit-for-Two-Tats">Tit-for-Two-Tats (Perdona 1)</option>
                        <option value="Grim Trigger">Gatillo Siniestro (Venganza Eterna)</option>
                        <option value="Pavlov">Pavlov (Gana-Qu√©date, Pierde-Cambia)</option>
                        <option value="Majority">Mayor√≠a de Votos (Sigue a la Multitud)</option>
                        <option value="Random_50">Aleatoria (50/50)</option>
                        <option value="Random_70">Aleatoria (70% C)</option>
                        <option value="Random_30">Aleatoria (30% C)</option>
                    </select>
                </div>
            </div>

            <!-- Controles de Ronda y Velocidad -->
            <div class="mt-4 grid grid-cols-2 gap-4">
                <div>
                    <label for="max-rounds" class="block text-sm font-medium text-gray-700">Rondas M√°ximas (M√°quinas)</label>
                    <input type="number" id="max-rounds" value="20" min="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 bg-gray-50 border"> <!-- DEFAULT: 20 -->
                </div>
                <div>
                    <label for="game-speed" class="block text-sm font-medium text-gray-700">Velocidad (ms por ronda)</label>
                    <input type="number" id="game-speed" value="50" min="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 bg-gray-50 border">
                </div>
            </div>

            <!-- Botones de Control -->
            <div class="flex space-x-3 mt-4">
                <button onclick="startGame()" id="start-btn" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150 shadow-md disabled:bg-gray-400">
                    Iniciar Juego
                </button>
                <button onclick="pauseGame()" id="pause-btn" style="display:none;" class="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150 shadow-md">
                    Pausar
                </button>
                <button onclick="endGame()" id="end-btn" style="display:none;" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150 shadow-md">
                    Terminar
                </button>
            </div>
            
            <!-- Historial de Partidas -->
            <div class="mt-6">
                <h3 class="text-lg font-semibold text-gray-800 border-b pb-2 mb-3">üìã Historial de Partidas</h3>
                <ul id="summary-list">
                    <!-- Res√∫menes de partidas aqu√≠ -->
                </ul>
            </div>
        </div>

        <!-- Panel del Tablero y Juego -->
        <div class="board-panel card">
            <h2 class="text-xl font-semibold mb-3 text-gray-800">üìä Tablero de Juego</h2>
            
            <div id="game-status" class="text-center font-bold text-lg p-3 rounded-md mb-4 bg-yellow-100 text-yellow-800 shadow-inner">
                Selecciona estrategias e Inicia el Juego
            </div>

            <!-- Cuadros de Puntaje -->
            <div class="grid grid-cols-2 gap-4 text-center mb-6">
                <div class="p-3 bg-blue-500 text-white rounded-lg shadow-lg">
                    <h3 class="text-lg font-semibold">Puntos J1</h3>
                    <p id="score-1" class="text-3xl font-extrabold">0</p>
                </div>
                <div class="p-3 bg-blue-500 text-white rounded-lg shadow-lg">
                    <h3 class="text-lg font-semibold">Puntos J2</h3>
                    <p id="score-2" class="text-3xl font-extrabold">0</p>
                </div>
            </div>

            <!-- Historial Visual Sincronizado -->
            <h3 class="text-md font-medium text-gray-700 mb-2">Historial de Jugadas:</h3>
            <div id="synchronized-history" class="shadow-inner">
                <div id="visual-history-1" class="visual-history-row"></div>
                <div id="visual-history-2" class="visual-history-row"></div>
            </div>
            
            <!-- Controles Manuales (Visibles solo si son "Humano") -->
            <div class="mt-6 grid grid-cols-2 gap-4">
                <div id="human-controls-1" class="player-card rounded-lg text-center shadow-md">
                    <p class="font-bold mb-3">Jugador 1 (Humano)</p>
                    <button id="btn-C-1" onclick="handleHumanMove(1, 'C')" class="btn-move btn-cooperate w-full rounded-lg mb-2">
                        Cooperar
                        <span class="key-hint">(Tecla A)</span>
                    </button>
                    <button id="btn-T-1" onclick="handleHumanMove(1, 'T')" class="btn-move btn-traitor w-full rounded-lg">
                        Traicionar
                        <span class="key-hint">(Tecla D)</span>
                    </button>
                </div>
                <div id="human-controls-2" class="player-card rounded-lg text-center shadow-md">
                    <p class="font-bold mb-3">Jugador 2 (Humano)</p>
                    <button id="btn-C-2" onclick="handleHumanMove(2, 'C')" class="btn-move btn-cooperate w-full rounded-lg mb-2">
                        Cooperar
                        <span class="key-hint">(Tecla J)</span>
                    </button>
                    <button id="btn-T-2" onclick="handleHumanMove(2, 'T')" class="btn-move btn-traitor w-full rounded-lg">
                        Traicionar
                        <span class="key-hint">(Tecla L)</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Variables Globales
        let gameActive = false;
        let currentRound = 0;
        let maxRounds = 20; // Default actualizado
        let gameSpeed = 50; 
        let scores = [0, 0]; 
        let history = []; 
        let machineGameLoop = null; 

        // Para Humano vs Humano/M√°quina: Almacena la jugada pendiente
        let pendingMoves = {};
        
        // Tiempo de espera para la animaci√≥n de procesado (reducido a 500ms)
        const ANIMATION_DELAY = 500; 

        // Matriz de Recompensas (PAYOFF[J1][J2] = [Score J1, Score J2])
        // C=0, T=1
        const PAYOFFS = [
            [[3, 3], [1, 5]], // Fila 0 (J1 coopera) -> [C,C] y [C,T]
            [[5, 1], [0, 0]]  // Fila 1 (J1 traiciona) -> [T,C] y [T,T]
        ];
        
        // --- L√ìGICA DE JUEGO ---

        /**
         * Inicializa o reinicia el juego.
         */
        function startGame() {
            if (gameActive) {
                endGame(); 
            }

            // 1. Obtener configuraci√≥n
            maxRounds = parseInt(document.getElementById('max-rounds').value) || 20;
            gameSpeed = parseInt(document.getElementById('game-speed').value) || 50;
            if (gameSpeed < 1) gameSpeed = 1;

            // 2. Resetear el estado
            scores = [0, 0];
            currentRound = 0;
            history = [];
            pendingMoves = {};

            // 3. Actualizar UI de inicio
            document.getElementById('score-1').textContent = '0';
            document.getElementById('score-2').textContent = '0';
            document.getElementById('visual-history-1').innerHTML = '';
            document.getElementById('visual-history-2').innerHTML = '';
            document.getElementById('synchronized-history').scrollLeft = 0;
            clearButtonStyles();

            document.getElementById('start-btn').disabled = true;
            document.getElementById('end-btn').style.display = 'inline-block';
            document.getElementById('pause-btn').style.display = 'inline-block';

            // 4. Determinar modos y bloquear selectores
            const strategy1 = document.getElementById('strategy-1').value;
            const strategy2 = document.getElementById('strategy-2').value;

            document.getElementById('strategy-1').disabled = true;
            document.getElementById('strategy-2').disabled = true;

            // 5. Iniciar el juego
            gameActive = true;
            
            toggleHumanControls(1);
            toggleHumanControls(2);

            if (strategy1 !== 'Human' && strategy2 !== 'Human') {
                // Modo M√°quina vs M√°quina
                document.getElementById('pause-btn').disabled = false;
                updateGameStatus(`Ronda 1 / ${maxRounds}. ¬°Jugando autom√°ticamente!`);
                machineGameLoop = setTimeout(runMachineRound, gameSpeed);
            } else {
                 // Modo Humano vs M√°quina o Humano vs Humano
                 document.getElementById('pause-btn').disabled = true;
                 updateGameStatus(`Ronda ${currentRound + 1} / ${maxRounds}. Esperando movimientos.`);
            }
        }

        /**
         * Funci√≥n unificada para manejar la jugada humana (click o tecla).
         */
        function handleHumanMove(playerWhoClicked, move) {
            if (!gameActive || currentRound >= maxRounds) return;
            
            const strategy1 = document.getElementById('strategy-1').value;
            const strategy2 = document.getElementById('strategy-2').value;
            const isPlayer1Human = strategy1 === 'Human';
            const isPlayer2Human = strategy2 === 'Human';

            // 1. Registrar movimiento
            pendingMoves[playerWhoClicked] = move;

            // 2. Resaltar bot√≥n de forma inmediata en Humano vs M√°quina, o solo registrar en H vs H
            if (!isPlayer1Human || !isPlayer2Human) {
                 highlightSelectedButton(playerWhoClicked, move);
            }

            if (isPlayer1Human && isPlayer2Human) {
                // Humano vs Humano: Esperar ambos
                if (pendingMoves[1] && pendingMoves[2]) {
                    processPendingRound(true);
                }
            } else if (isPlayer1Human) {
                // Humano 1 vs M√°quina 2: La m√°quina juega inmediatamente
                if (playerWhoClicked === 1) {
                    pendingMoves[2] = getStrategyMove(2, strategy2);
                    processPendingRound(false);
                }
            } else if (isPlayer2Human) {
                // M√°quina 1 vs Humano 2: La m√°quina juega inmediatamente
                 if (playerWhoClicked === 2) {
                    pendingMoves[1] = getStrategyMove(1, strategy1);
                    processPendingRound(false);
                }
            }
        }

        /**
         * Procesa la ronda pendiente una vez que ambos movimientos est√°n listos.
         * @param {boolean} isHumanVsHuman - Indica si la ronda es H vs H para manejar la visualizaci√≥n.
         */
        function processPendingRound(isHumanVsHuman) {
            // Deshabilitar botones mientras se procesa la ronda
            toggleHumanControls(1, true); 
            toggleHumanControls(2, true); 
            document.getElementById('game-status').textContent = 'Procesando ronda...';

            const move1 = pendingMoves[1];
            const move2 = pendingMoves[2];
            
            // Si es H vs H, mostrar selecciones justo antes de procesar
            if (isHumanVsHuman) {
                highlightSelectedButton(1, move1);
                highlightSelectedButton(2, move2);
            }

            pendingMoves = {}; // Limpiar para la siguiente ronda

            setTimeout(() => {
                processMoves(move1, move2);
                clearButtonStyles();

                if (gameActive && currentRound < maxRounds) {
                     updateGameStatus(`Ronda ${currentRound + 1} / ${maxRounds}. Esperando movimientos.`);
                     toggleHumanControls(1); 
                     toggleHumanControls(2); 
                }
            }, ANIMATION_DELAY); // Usar el tiempo de espera reducido
        }


        /**
         * Ejecuta una sola ronda en modo M√°quina vs M√°quina.
         */
        function runMachineRound() {
            if (!gameActive || currentRound >= maxRounds) {
                endGame();
                return;
            }

            const strategy1 = document.getElementById('strategy-1').value;
            const strategy2 = document.getElementById('strategy-2').value;

            const move1 = getStrategyMove(1, strategy1);
            const move2 = getStrategyMove(2, strategy2);

            processMoves(move1, move2);

            if (gameActive && currentRound < maxRounds) {
                machineGameLoop = setTimeout(runMachineRound, gameSpeed);
            } else {
                endGame();
            }
        }

        /**
         * Procesa los movimientos, actualiza puntuaciones, historial visual y estado.
         */
        function processMoves(move1, move2) {
            if (!gameActive) return;

            const idx1 = move1 === 'C' ? 0 : 1;
            const idx2 = move2 === 'C' ? 0 : 1;
            
            const [score1, score2] = PAYOFFS[idx1][idx2];

            // 1. Actualizar puntuaciones
            scores[0] += score1;
            scores[1] += score2;

            document.getElementById('score-1').textContent = scores[0];
            document.getElementById('score-2').textContent = scores[1];

            // 2. Registrar historial
            history.push({ move1, move2, score1, score2 });
            currentRound++;

            // 3. Actualizar historial visual (C√≠rculos)
            updateVisualHistory(1, move1);
            updateVisualHistory(2, move2);
            
            // 4. Actualizar estado solo si estamos en modo m√°quina vs m√°quina
            const strategy1 = document.getElementById('strategy-1').value;
            const strategy2 = document.getElementById('strategy-2').value;
            if (strategy1 !== 'Human' && strategy2 !== 'Human') {
                 updateGameStatus(`Ronda ${currentRound} / ${maxRounds} (Mov: ${move1} vs ${move2}). Pts: ${score1} / ${score2}`);
            }

            // 5. Verificar fin del juego
            if (currentRound >= maxRounds) {
                endGame();
            }
        }

        /**
         * Determina el movimiento de una estrategia de m√°quina.
         */
        function getStrategyMove(player, strategy) {
            const opponent = player === 1 ? 2 : 1;
            const lastRound = history.length > 0 ? history[history.length - 1] : null;
            const opponentHistory = history.map(h => opponent === 1 ? h.move1 : h.move2);

            const getOpponentMove = (h) => (opponent === 1 ? h.move1 : h.move2);
            const getPlayerMove = (h) => (player === 1 ? h.move1 : h.move2);
            const getPlayerScore = (h) => (player === 1 ? h.score1 : h.score2);

            switch (strategy) {
                case 'Always Cooperate':
                    return 'C';
                case 'Always Traitor':
                    return 'T';
                
                // Estrategias aleatorias con sesgo
                case 'Random_50':
                    return Math.random() < 0.5 ? 'C' : 'T';
                case 'Random_70':
                    return Math.random() < 0.7 ? 'C' : 'T';
                case 'Random_30':
                    return Math.random() < 0.3 ? 'C' : 'T';

                case 'Tit-for-Tat':
                    return lastRound ? getOpponentMove(lastRound) : 'C';

                case 'Tit-for-Two-Tats':
                    if (!lastRound || history.length < 2) return 'C';
                    
                    const secondToLast = history[history.length - 2];
                    const oppLast = getOpponentMove(lastRound);
                    const oppSecondLast = getOpponentMove(secondToLast);

                    if (oppLast === 'T' && oppSecondLast === 'T') {
                        return 'T';
                    }
                    return 'C';

                case 'Grim Trigger':
                    const hasOpponentTraitor = opponentHistory.includes('T');
                    return hasOpponentTraitor ? 'T' : 'C';

                case 'Pavlov':
                    if (!lastRound) return 'C'; 
                    
                    const lastMove = getPlayerMove(lastRound);
                    const lastScore = getPlayerScore(lastRound);

                    // Gana-Qu√©date: 3 (C,C) o 5 (T,C)
                    if (lastScore === 3 || lastScore === 5) {
                        return lastMove;
                    } 
                    // Pierde-Cambia: 0 (T,T) o 1 (C,T)
                    else {
                        return lastMove === 'C' ? 'T' : 'C';
                    }
                
                case 'Majority':
                    const coopCount = opponentHistory.filter(m => m === 'C').length;
                    const traitorCount = opponentHistory.filter(m => m === 'T').length;
                    
                    return coopCount > traitorCount ? 'C' : 'T';
                    
                default:
                    return 'C';
            }
        }

        /**
         * Actualiza el historial visual de c√≠rculos y mantiene el scroll al final.
         */
        function updateVisualHistory(player, move) {
            const historyDiv = document.getElementById(`visual-history-${player}`);
            const circle = document.createElement('span');
            circle.className = `move-circle ${move} shadow-sm`;
            historyDiv.appendChild(circle);

            // Mantiene el scroll del contenedor padre sincronizado al final
            const synchronizedContainer = document.getElementById('synchronized-history');
            synchronizedContainer.scrollLeft = synchronizedContainer.scrollWidth;
        }

        /**
         * Finaliza el juego, detiene loops y muestra el resultado final.
         */
        function endGame() {
            if (!gameActive) return; 

            gameActive = false;
            
            if (machineGameLoop) {
                clearTimeout(machineGameLoop);
                machineGameLoop = null;
            }

            document.getElementById('pause-btn').style.display = 'none';
            document.getElementById('end-btn').style.display = 'none';
            document.getElementById('start-btn').disabled = false;
            document.getElementById('pause-btn').textContent = 'Pausar';
            document.getElementById('pause-btn').onclick = pauseGame;
            document.getElementById('strategy-1').disabled = false;
            document.getElementById('strategy-2').disabled = false;
            clearButtonStyles();
            
            const finalScore1 = scores[0];
            const finalScore2 = scores[1];
            const strategy1 = document.getElementById('strategy-1').value;
            const strategy2 = document.getElementById('strategy-2').value;

            let winner = '';
            if (finalScore1 > finalScore2) {
                winner = 'üèÜ Gan√≥ Jugador 1';
            } else if (finalScore2 > finalScore1) {
                winner = 'üèÜ Gan√≥ Jugador 2';
            } else {
                winner = 'ü§ù Empate';
            }

            updateGameStatus(`üéä Juego terminado - ${winner} en ${currentRound} rondas`);

            // Agregar al historial de partidas (Resumen)
            const summaryText = `${strategy1} vs ${strategy2} | ${finalScore1} - ${finalScore2} | ${winner}`;
            const summaryItem = document.createElement('li');
            summaryItem.className = 'match-summary-item';
            summaryItem.textContent = summaryText;
            document.getElementById('summary-list').prepend(summaryItem);

            toggleHumanControls(1);
            toggleHumanControls(2);
        }

        /**
         * Muestra/oculta y habilita/deshabilita los controles manuales.
         */
        function toggleHumanControls(player, disable = false) {
            const strategy = document.getElementById(`strategy-${player}`).value;
            const controlsDiv = document.getElementById(`human-controls-${player}`);
            const isHuman = strategy === 'Human';

            controlsDiv.style.display = isHuman ? 'block' : 'none';

            if (isHuman) {
                const btnC = document.getElementById(`btn-C-${player}`);
                const btnT = document.getElementById(`btn-T-${player}`);
                
                const isDisabled = disable || !gameActive || (machineGameLoop && machineGameLoop !== null);
                
                btnC.disabled = isDisabled;
                btnT.disabled = isDisabled;
            }
        }

        /**
         * Resalta el bot√≥n seleccionado por un jugador humano.
         */
        function highlightSelectedButton(player, move) {
            const btnC = document.getElementById(`btn-C-${player}`);
            const btnT = document.getElementById(`btn-T-${player}`);

            // Limpiar estilos del jugador actual
            btnC.classList.remove('selected-cooperate', 'selected-traitor');
            btnT.classList.remove('selected-cooperate', 'selected-traitor');

            if (move === 'C') {
                btnC.classList.add('selected-cooperate');
            } else if (move === 'T') {
                btnT.classList.add('selected-traitor');
            }
        }
        
        /**
         * Limpia los estilos de selecci√≥n de todos los botones humanos.
         */
        function clearButtonStyles() {
             document.querySelectorAll('.btn-move').forEach(btn => {
                btn.classList.remove('selected-cooperate', 'selected-traitor');
            });
        }
        
        // --- CONTROL DE ESTADO Y UI ---
        
        /**
         * Pausa el bucle de juego de m√°quina.
         */
        function pauseGame() {
            if (machineGameLoop) {
                clearTimeout(machineGameLoop);
                machineGameLoop = null;
                document.getElementById('pause-btn').textContent = 'Continuar';
                document.getElementById('pause-btn').onclick = continueGame;
                updateGameStatus(`‚è∏Ô∏è Juego Pausado.`);
            }
        }

        /**
         * Contin√∫a el bucle de juego de m√°quina.
         */
        function continueGame() {
            if (!machineGameLoop && gameActive) {
                document.getElementById('pause-btn').textContent = 'Pausar';
                document.getElementById('pause-btn').onclick = pauseGame;
                updateGameStatus(`Ronda ${currentRound + 1} / ${maxRounds}. ¬°Jugando autom√°ticamente!`);
                runMachineRound();
            }
        }

        /**
         * Actualiza el mensaje de estado del juego.
         */
        function updateGameStatus(message) {
            const statusDiv = document.getElementById('game-status');
            statusDiv.textContent = message;

            if (message.includes('Jugando') || message.includes('Juega')) {
                statusDiv.className = 'text-center font-bold text-lg p-3 rounded-md mb-4 bg-green-100 text-green-800 shadow-inner';
            } else if (message.includes('Pausado')) {
                statusDiv.className = 'text-center font-bold text-lg p-3 rounded-md mb-4 bg-yellow-100 text-yellow-800 shadow-inner';
            } else if (message.includes('terminado')) {
                statusDiv.className = 'text-center font-bold text-lg p-3 rounded-md mb-4 bg-blue-100 text-blue-800 shadow-inner';
            } else if (message.includes('Esperando')) {
                 statusDiv.className = 'text-center font-bold text-lg p-3 rounded-md mb-4 bg-purple-100 text-purple-800 shadow-inner';
            } else {
                 statusDiv.className = 'text-center font-bold text-lg p-3 rounded-md mb-4 bg-yellow-100 text-yellow-800 shadow-inner';
            }
        }
        
        // --- EVENTOS DE TECLADO ---

        function handleKeyDown(event) {
            if (!gameActive) return;

            const key = event.key.toUpperCase();
            const strategy1 = document.getElementById('strategy-1').value;
            const strategy2 = document.getElementById('strategy-2').value;

            switch (key) {
                // JUGADOR 1 (A: Cooperar, D: Traicionar)
                case 'A': 
                    if (strategy1 === 'Human' && !document.getElementById('btn-C-1').disabled) {
                        handleHumanMove(1, 'C');
                        event.preventDefault(); 
                    }
                    break;
                case 'D': 
                    if (strategy1 === 'Human' && !document.getElementById('btn-T-1').disabled) {
                        handleHumanMove(1, 'T');
                        event.preventDefault(); 
                    }
                    break;
                // JUGADOR 2 (J: Cooperar, L: Traicionar)
                case 'J': 
                    if (strategy2 === 'Human' && !document.getElementById('btn-C-2').disabled) {
                        handleHumanMove(2, 'C');
                        event.preventDefault(); 
                    }
                    break;
                case 'L': 
                    if (strategy2 === 'Human' && !document.getElementById('btn-T-2').disabled) {
                        handleHumanMove(2, 'T');
                        event.preventDefault(); 
                    }
                    break;
            }
        }


        // Inicializa controles y oyentes al cargar la p√°gina
        window.onload = function() {
            document.getElementById('strategy-1').addEventListener('change', () => toggleHumanControls(1));
            document.getElementById('strategy-2').addEventListener('change', () => toggleHumanControls(2));
            document.addEventListener('keydown', handleKeyDown);

            // Asegurar que los controles de Humano vs TFT se muestren correctamente al inicio.
            toggleHumanControls(1);
            toggleHumanControls(2);
        };
    </script>
</body>
</html>
